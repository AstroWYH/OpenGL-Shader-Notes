# OpenGL各顶点坐标空间

- 模型空间(Local Space，局部空间，或者称为物体空间(Object Space))
- 世界空间(World Space)
- 观察空间(View Space，或者称为视觉空间(Eye Space))
- 裁剪空间(Clip Space)
- 屏幕空间(Screen Space)

![coordinate_systems](https://hanbabang-1311741789.cos.ap-chengdu.myqcloud.com/Pics/coordinate_systems.png)

1. 局部坐标是对象相对于局部原点的坐标，也是物体起始的坐标。
2. 下一步是将局部坐标变换为世界空间坐标，世界空间坐标是处于一个更大的空间范围的。这些坐标相对于世界的全局原点，它们会和其它物体一起相对于世界的原点进行摆放。
3. 接下来我们将世界坐标变换为观察空间坐标，使得每个坐标都是从摄像机或者说观察者的角度进行观察的。
4. 坐标到达观察空间之后，我们需要将其投影到裁剪坐标。裁剪坐标会被处理至-1.0到1.0的范围内，并判断哪些顶点将会出现在屏幕上。
5. 最后，我们将裁剪坐标变换为屏幕坐标，我们将使用一个叫做视口变换(Viewport Transform)的过程。视口变换将位于-1.0到1.0范围的坐标变换到由glViewport函数所定义的坐标范围内。最后变换出来的坐标将会送到光栅器，将其转化为片段。

## 模型空间

局部空间是指物体所在的坐标空间，即对象最开始所在的地方。想象你在一个建模软件（比如说Blender）中创建了一个立方体。你创建的立方体的原点有可能位于(0, 0, 0)，即便它有可能最后在程序中处于完全不同的位置。甚至有可能你创建的所有模型都以(0, 0, 0)为初始位置（译注：然而它们会最终出现在世界的不同位置）。所以，**你的模型的所有顶点都是在模型空间中：它们相对于你的物体来说都是局部的。**

我们一直使用的那个箱子的顶点是被设定在**-0.5到0.5的坐标范围中，(0, 0)是它的原点。这些都是局部坐标。**

## 世界空间

如果我们将我们所有的物体导入到程序当中，它们**有可能会全挤在世界的原点(0, 0, 0)**上，这并不是我们想要的结果。我们想为每一个物体定义一个位置，从而能在更大的世界当中放置它们。世界空间中的坐标正如其名：是指顶点相对于（游戏）世界的坐标。如果你希望将物体分散在世界上摆放（特别是非常真实的那样），这就是你希望物体变换到的空间。物体的坐标将会从局部变换到世界空间；该变换是由**模型矩阵(Model Matrix)**实现的。

**模型矩阵是一种变换矩阵，它能通过对物体进行位移、缩放、旋转**来将它置于它本应该在的位置或朝向。你可以将它想像为变换一个房子，你需要先将它缩小（它在局部空间中太大了），并将其位移至郊区的一个小镇，然后在y轴上往左旋转一点以搭配附近的房子。你也可以把上一节将箱子到处摆放在场景中用的那个矩阵大致看作一个模型矩阵；我们将箱子的局部坐标变换到场景/世界中的不同位置。

## 观察空间

观察空间经常被人们称之OpenGL的摄像机(Camera)（所以有时也称为摄像机空间(Camera Space)或视觉空间(Eye Space)）。**观察空间是将世界空间坐标转化为用户视野前方的坐标而产生的结果**。因此观察空间就是从摄像机的视角所观察到的空间。而这通常是由一系列的**位移和旋转**的组合来完成，平移/旋转场景从而使得特定的对象被变换到摄像机的前方。这些组合在一起的变换通常存储在一个**观察矩阵(View Matrix)**里，它被用来将世界坐标变换到观察空间。在下一节中我们将深入讨论如何创建一个这样的观察矩阵来模拟一个摄像机。

## 裁剪空间

在一个顶点着色器运行的最后，OpenGL期望所有的坐标都能落在**一个特定的范围**内，且**任何在这个范围之外的点都应该被裁剪掉(Clipped)。**被裁剪掉的坐标就会被忽略，所以**剩下的坐标就将变为屏幕上可见的片段。**这也就是裁剪空间(Clip Space)名字的由来。

因为将所有可见的坐标都指定在-1.0到1.0的范围内不是很直观，所以我们会指定自己的坐标集(Coordinate Set)并将它变换回标准化设备坐标系，就像OpenGL期望的那样。

为了将顶点坐标**从观察变换到裁剪空间**，我们需要定义一个**投影矩阵(Projection Matrix)**，它指定了一个范围的坐标，比如在每个维度上的**-1000到1000**。投影矩阵接着会将在这个指定的范围内的坐标变换为**标准化设备坐标的范围(-1.0, 1.0)**。所有在范围外的坐标不会被映射到在-1.0到1.0的范围之间，所以会被裁剪掉。在上面这个投影矩阵所指定的范围内，**坐标(1250, 500, 750)将是不可见的，这是由于它的x坐标超出了范围，它被转化为一个大于1.0的标准化设备坐标，所以被裁剪掉了。**

```
如果只是图元(Primitive)，例如三角形，的一部分超出了裁剪体积(Clipping Volume)，则OpenGL会重新构建这个三角形为一个或多个三角形让其能够适合这个裁剪范围。
```

由投影矩阵创建的**观察箱**(Viewing Box)被称为**(Frustum)(视锥体--Games101)，每个出现在视锥体范围内的坐标都会最终出现在用户的屏幕上。**将特定范围内的坐标转化到**标准化设备坐标系(NDC)**的过程（而且它很容易被映射到2D观察空间坐标）被称之为**投影(Projection)**，因为使用投影矩阵能将3D坐标投影(Project)到很容易映射到2D的标准化设备坐标系中。

一旦所有顶点被变换到裁剪空间，最终的操作——**透视除法(Perspective Division)**将会执行，**在这个过程中我们将位置向量的x，y，z分量分别除以向量的齐次w分量**；**透视除法是将4D裁剪空间坐标变换为3D标准化设备坐标的过程**。**这一步会在每一个顶点着色器运行的最后被自动执行。**

在这一阶段之后，最终的坐标将会被映射到**屏幕空间**中（使用glViewport中的设定），并被变换成片段。

将观察坐标变换为裁剪坐标的投影矩阵可以为两种不同的形式，每种形式都定义了不同的视锥体。我们可以选择创建一个正交投影矩阵(Orthographic Projection Matrix)或一个透视投影矩阵(Perspective Projection Matrix)。

## 正交投影

正交投影矩阵**定义了一个类似立方体的平截头箱，它定义了一个裁剪空间**，**在这空间之外的顶点都会被裁剪掉**。创建一个正交投影矩阵需要指定可见视锥体的宽、高和长度。在使用正交投影矩阵变换至裁剪空间之后处于这个视锥体内的所有坐标将不会被裁剪掉。它的视锥体看起来像一个容器：

![orthographic projection frustum](https://hanbabang-1311741789.cos.ap-chengdu.myqcloud.com/Pics/orthographic_frustum.png)

上面的视锥体定义了可见的坐标，它由由**宽、高、近(Near)平面和远(Far)平面**所指定。任何出现在近平面之前或远平面之后的坐标都会被裁剪掉。正交视锥体直接将视锥体内部的所有坐标映射为标准化设备坐标，因为每个向量的w分量都没有进行改变；如果w分量等于1.0，透视除法则不会改变这个坐标。

要创建一个正交投影矩阵，我们可以使用GLM的内置函数`glm::ortho`：

```c++
glm::ortho(0.0f, 800.0f, 0.0f, 600.0f, 0.1f, 100.0f);
```

**前两个参数指定了视锥体的左右坐标，第三和第四参数指定了视锥体的底部和顶部。****通过这四个参数我们定义了近平面和远平面的大小，然后第五和第六个参数则定义了近平面和远平面的距离。这个投影矩阵会将处于这些x，y，z值范围内的坐标变换为标准化设备坐标。**

正交投影矩阵直接将坐标映射到2D平面中，即你的屏幕，但实际上一个直接的投影矩阵会产生**不真实**的结果，因为这个投影没有将透视(Perspective)考虑进去。所以我们需要透视投影矩阵来解决这个问题。

## 透视投影

![perspective](https://hanbabang-1311741789.cos.ap-chengdu.myqcloud.com/Pics/perspective.png)

正如你看到的那样，由于透视，这两条线在很远的地方看起来会相交。这正是透视投影想要模仿的效果，它是使用透视投影矩阵来完成的。**这个投影矩阵将给定的视锥体范围映射到裁剪空间，**除此之外还修改了每个顶点坐标的w值，从而使得离观察者越远的顶点坐标w分量越大**<!--这句话怎么理解？-->。被变换到裁剪空间的坐标都会在-w到w的范围之间（任何大于这个范围的坐标都会被裁剪掉）。**

```
我的注释：这个裁剪空间应该是fov、宽高比、远近平面来框定的，这样透视投影后裁剪空间的坐标才刚好都在(-w,w)之间。
```

**OpenGL要求所有**可见的坐标都落在-1.0到1.0范围**内，作为顶点着色器最后的输出，因此，**一旦坐标在裁剪空间内之后，透视除法就会被应用到裁剪空间坐标上**：**

![image-20220426205647474](https://hanbabang-1311741789.cos.ap-chengdu.myqcloud.com/Pics/image-20220426205647474.png)

**顶点坐标的每个分量都会除以它的w分量，距离观察者越远顶点坐标就会越小<!--这句话怎么理解？-->。这是也是w分量非常重要的另一个原因，它能够帮助我们进行透视投影******。最后的结果坐标就是处于标准化设备空间中的****。

```
我的注释：观察空间(4D)-----（正交or透视）投影矩阵-----裁剪空间(4D)(-----透视除法（除以w）-----NDC标准设备空间(3D)
```

如果你对正交投影矩阵和透视投影矩阵是如何计算的很感兴趣（且不会对数学感到恐惧的话）我推荐这篇由Songho写的[文章](http://www.songho.ca/opengl/gl_projectionmatrix.html)。

在GLM中可以这样创建一个透视投影矩阵：

```c++
glm::mat4 proj = glm::perspective(glm::radians(45.0f), (float)width/(float)height, 0.1f, 100.0f);
```

同样，`glm::perspective`所做的其实就是创建了一个定义了可视空间的大**视锥体**，任何在这个**视锥体以外的东西最后都不会出现在裁剪空间体积内**，并且将会受到裁剪。一个透视视锥体可以被看作一个不均匀形状的箱子，在这个箱子内部的每个坐标都会被映射到裁剪空间上的一个点。下面是一张透视视锥体的图片：

![ perspective_frustum](https://hanbabang-1311741789.cos.ap-chengdu.myqcloud.com/Pics/perspective_frustum.png)

**它的**第一个参数**定义了**fov的值，它表示的是视野(Field of View)**，并且设置了观察空间的大小。如果想要一个**真实的观察效果**，它的值**通常设置为45.0f**，但想要一个末日风格的结果你可以将其设置一个更大的值。**第二个参数设置了宽高比**，由视口的宽除以高所得。**第三和第四个参数设置了视锥体的近和远平面**。**我们通常设置近距离为0.1f，而远距离设为100.0f。所有在近平面和远平面内且处于视锥体内的顶点都会被渲染。

	当你把透视矩阵的 *near* 值设置太大时（如10.0f），OpenGL会将靠近摄像机的坐标（在0.0f和10.0f之间）都裁剪掉，这会导致一个你在游戏中很熟悉的视觉效果：在太过靠近一个物体的时候你的视线会直接穿过去。

## 把它们都组合到一起

我们为上述的每一个步骤都创建了一个变换矩阵：模型矩阵、观察矩阵和投影矩阵。一个顶点坐标将会根据以下过程被变换到裁剪坐标：

![image-20220426205658616](https://hanbabang-1311741789.cos.ap-chengdu.myqcloud.com/Pics/image-20220426205658616.png)

注意矩阵运算的顺序是相反的（记住我们需要**从右往左**阅读矩阵的乘法）。最后的顶点应该被赋值到**顶点着色器中的<var>gl_Position**</var>，OpenGL将会自动进行透视除法和裁剪。

```
我的注释：gl_Position被赋值时，还没有进行透视除法（除以w），和空间外部的裁剪。
```

顶点着色器的输出要求所有的顶点都在裁剪空间内，这正是我们刚才使用变换矩阵所做的。OpenGL然后对**裁剪坐标**执行**透视除法**从而将它们变换到**标准化设备坐标**。**OpenGL会使用glViewPort内部的参数来将标准化设备坐标映射到**屏幕坐标****，每个坐标都关联了一个屏幕上的点（在我们的例子中是一个800x600的屏幕）。这个过程称为**视口变换**。

## 进入3D

#### OpenGL右手坐标系（DirectX左手坐标系）

![coordinate_systems_right_handed](https://hanbabang-1311741789.cos.ap-chengdu.myqcloud.com/Pics/coordinate_systems_right_handed.png)

```
沿着正y轴方向伸出你的右臂，手指着上方。
大拇指指向右方。
食指指向上方。
中指向下弯曲90度。
如果你的动作正确，那么你的大拇指指向正x轴方向，食指指向正y轴方向，中指指向正z轴方向。
注：在标准化设备坐标系中OpenGL实际上使用的是左手坐标系（投影矩阵交换了左右手）（？？？）
```

#### 模型矩阵

```c++
glm::mat4 model; // 在此之前要传入顶点的局部空间坐标，然后model * position。
model = glm::rotate(model, glm::radians(-55.0f), glm::vec3(1.0f, 0.0f, 0.0f));
```

#### 观察矩阵

```c++
glm::mat4 view;
// 注意，我们将矩阵向我们要进行移动场景的反方向移动。
view = glm::translate(view, glm::vec3(0.0f, 0.0f, -3.0f));
```

#### 投影矩阵

```c++
glm::mat4 projection;
projection = glm::perspective(glm::radians(45.0f), screenWidth / screenHeight, 0.1f, 100.0f);
```

#### 顶点着色器

```c++
#version 330 core
layout (location = 0) in vec3 aPos;
...
uniform mat4 model;
uniform mat4 view;
uniform mat4 projection;

void main()
{
    // 注意乘法要从右向左读
    gl_Position = projection * view * model * vec4(aPos, 1.0);
    ...
}
```

#### 模型矩阵传入着色器

```c++
int modelLoc = glGetUniformLocation(ourShader.ID, "model"));
glUniformMatrix4fv(modelLoc, 1, GL_FALSE, glm::value_ptr(model));
... // 观察矩阵和投影矩阵与之类似
```



## 参考链接

[坐标系统 - LearnOpenGL CN (learnopengl-cn.github.io)](https://learnopengl-cn.github.io/01 Getting started/08 Coordinate Systems/)

[Editing LearnOpenGL-CN/08 Coordinate Systems.md at new-theme · AstroWYH/LearnOpenGL-CN (github.com)](https://github.com/AstroWYH/LearnOpenGL-CN/edit/new-theme/docs/01 Getting started/08 Coordinate Systems.md)